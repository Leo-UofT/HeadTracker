#!/usr/bin/python

from array import array
import csv

import set_common as s

f = open("../gui/src/basetrackersettings.h","w")
f.write("""\
/*
* This file is part of the Head Tracker distribution (https://github.com/dlktdr/headtracker)
* Copyright (c) 2022 Cliff Blackburn
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**********************************************
 *
 *  !!! THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY !!!
 *
 *  Modify settings.csv and execute buildsettings.py to generate this GUI header
 *
 ***********************************************/

#pragma once

#include <QObject>
#include <QSettings>

class BaseTrackerSettings : public QObject
{
  Q_OBJECT
public:
""")

s.readSettings()

# Write the constants to the file
for row in s.const:
  if "float" in row[s.coltype]:
    f.write("  static constexpr "  + s.typeToC(row[s.coltype]) + " " + row[s.colname] + " = {}".format(float(row[s.coldefault])) + "f;\n")
  else:
    f.write("  static constexpr "  + s.typeToC(row[s.coltype]) + " " + row[s.colname] + " = " + row[s.coldefault] + ";\n")

f.write("\n  QMap<QString, QString> descriptions;\n");

# Write the Constructor
f.write("\n  BaseTrackerSettings(QObject *parent=nullptr) : \n    QObject(parent)\n  {\n")
for row in s.settings:
  if "bool" in row[s.coltype]:
    f.write("    _setting[\"" + row[s.colname].lower() + "\"] = " + row[s.coldefault].lower() + ";\n")
  else:
    f.write("    _setting[\"" + row[s.colname].lower() + "\"] = " + row[s.coldefault] + ";\n")

for row in s.settingsarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  name = row[s.colname][:start].lower()

  # Fill arrays with the default values
  if "char" in row[s.coltype]:
    f.write("    _setting[\"" + row[s.colname][:start].lower() + "\"] = QString(\"" + row[s.coldefault] + "\");\n")
  else:
    f.write("    _setting[\"" + row[s.colname][:start].lower() + "\"] = QVariantList();\n")

for row in s.data:
  f.write("    _dataItems[\"" + row[s.colname].lower() + "\"] = false;\n")

# Add the descriptions
for row in s.settings:
  f.write("    descriptions[\"" + row[s.colname].lower() + "\"] = \"" + row[s.coldesc] + "\";\n")
for row in s.data:
  f.write("    descriptions[\"" + row[s.colname].lower() + "\"] = \"" + row[s.coldesc] + "\";\n")
for row in s.settingsarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  name = row[s.colname][:start].lower()
  f.write("    descriptions[\"" + name.lower() + "\"] = \"" + row[s.coldesc] + "\";\n")
for row in s.dataarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  name = row[s.colname][:start].lower()
  f.write("    descriptions[\"" + name.lower() + "\"] = \"" + row[s.coldesc] + "\";\n")

for row in s.dataarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  name = row[s.colname][:start].lower()
  f.write("    _dataItems[\"" + name + "\"] = false;\n")

f.write("    _deviceDataItems = _dataItems;\n")

# Write the get + set functions
f.write("  }\n\n")

for row in s.settings:
  if row[s.coltype].lower().strip() == "bool":
    txt = """\
  // {desc}
  {dtype} get{cname}() {{return _setting[\"{name}\"]{vartype};}}
  void set{cname}({dtype} val={deflt}) {{ _setting["{name}"] = val; }}\n
""".format(cname = row[s.colname], name = row[s.colname].lower(), dtype = s.typeToC(row[s.coltype]), deflt = row[s.coldefault].lower(), minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], vartype = s.QVariantRet(row[s.coltype].lower()))
  elif row[s.coltype].lower().strip() == "float":
    txt = """\
  // {desc}
  {dtype} get{cname}() {{
    return _setting[\"{name}\"]{vartype};
  }}
  bool set{cname}({dtype} val={deflt}) {{
    if(val >= {minv} && val <= {maxv}) {{
      _setting["{name}"] = QString::number(val,'g',{round});
      return true;
    }}
    return false;
  }}\n\n
""".format(cname = row[s.colname], name = row[s.colname].lower(), dtype = s.typeToC(row[s.coltype]), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], vartype = s.QVariantRet(row[s.coltype].lower()), round = row[s.colround])
  elif (row[s.coltype].lower().strip()[:1] == 'u') and (row[s.colmin].strip() == "0"):
    txt = """\
  // {desc}
  {dtype} get{cname}() {{
    return _setting[\"{name}\"]{vartype};
  }}
  bool set{cname}({dtype} val={deflt}) {{
    if(val <= {maxv}) {{
      _setting["{name}"] = val;
      return true;
    }}
    return false;
  }}\n\n""".format(cname = row[s.colname], name = row[s.colname].lower(), dtype = s.typeToC(row[s.coltype]), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], vartype = s.QVariantRet(row[s.coltype].lower()), round = row[s.colround])
  else:
    txt = """\
  // {desc}
  {dtype} get{cname}() {{
    return _setting[\"{name}\"]{vartype};
  }}
  bool set{cname}({dtype} val={deflt}) {{
    if(val >= {minv} && val <= {maxv}) {{
      _setting["{name}"] = val;
      return true;
    }}
    return false;
  }}\n\n""".format(cname = row[s.colname], name = row[s.colname].lower(), dtype = s.typeToC(row[s.coltype]), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], vartype = s.QVariantRet(row[s.coltype].lower()))
  f.write(txt)

# Get & Set for the Settings Arrays
for row in s.settingsarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  if row[s.coltype].lower().strip() != "char":
    txt = ""
    a = 1
#    txt = """\
#  // {desc}
#  void get{cname}({dtype} dest[{len}]) {{memcpy(dest, {name}, sizeof({dtype}) * {len});}}
#  bool set{cname}(const {dtype} val[{len}]) {{
#    bool changed = false;
#    for(int i=0; i < {len}; i++) {{
#      if({name}[i] >= {minv} && {name}[i] <= {maxv}) {{
#        {name}[i] = val[i];
#        changed = true;
#      }}
#    }}
#    return changed;
#  }}\n\n""".format(cname = row[s.colname][:start], name = row[s.colname][:start].lower(), dtype = s.typeToC(row[s.coltype].strip()), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], len = arraylength )
  else:
    txt = """\
  // {desc}
  QString get{cname}() {{
    return _setting[\"{name}\"]{vartype};
  }}
  void set{cname}(const QString &val) {{
    _setting[\"{name}\"] = val;
  }}\n\n""".format(cname = row[s.colname][:start], name = row[s.colname][:start].lower(), dtype = s.typeToC(row[s.coltype].strip()), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc], len = arraylength, vartype = s.QVariantRet(row[s.coltype].lower()) )

  f.write(txt)

# Get Functions for the Data Items
for row in s.data:
  txt = """\
  // {desc}
  {dtype} getData{cname}() {{ return _data[\"{name}\"]{vartype}; }}\n
""".format(cname = row[s.colname], name = row[s.colname].lower(), dtype = s.typeToC(row[s.coltype].lower().strip()), deflt = row[s.coldefault], minv = row[s.colmin], maxv = row[s.colmax], desc = row[s.coldesc],vartype = s.QVariantRet(row[s.coltype].lower().strip()))
  f.write(txt)

# Get for the Data Arrays
for row in s.dataarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  if row[s.coltype].lower().strip() == "char":
    txt = """\
  // {desc}
  QString getData{cname}() {{ return _data[\"{name}\"].toString(); }}\n
""".format(cname = row[s.colname][:start], name = row[s.colname][:start].lower(), desc = row[s.coldesc])
    f.write(txt)

f.write("  QStringList allDataItems() {\n    QStringList rv;\n")
for row in s.data:
  f.write("    rv.append(\"" + row[s.colname].lower() + "\");\n")
for row in s.dataarrays:
  start = row[s.colname].find("[")
  end = row[s.colname].find("]")
  arraylength = row[s.colname][start+1:end]
  if row[s.coltype].strip() == "char":
    f.write("    rv.append(\"" + row[s.colname][:start].lower() + "\");\n")
  else:
    for x in range(int(arraylength)):
      f.write("    rv.append(\"" + row[s.colname][:start].lower() + "[" + str(x) + "]\");\n")

f.write("    return rv;\n  }\n")

f.write("""\
protected:
  QVariantMap _setting; // Data in the GUI
  QVariantMap _deviceSettings; // Data stored on the device
  QVariantMap _data; // Realtime data
  QMap<QString, bool> _dataItems; // Data items that requested to be sent
  QMap<QString, bool> _deviceDataItems; // What items the device is currently sending

  \n""")

# Close Class
f.write("};\n")

f.close()

print("Gernerated GUI Settings Base Class")